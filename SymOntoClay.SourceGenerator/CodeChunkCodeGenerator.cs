using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace SymOntoClay.SourceGenerator
{
    public class CodeChunkCodeGenerator
    {
        public CodeChunkCodeGenerator(GeneratorExecutionContext context)
        {
            _context = context;
        }

        private readonly GeneratorExecutionContext _context;

        public void Run(TargetCodeChunksCompilationUnit targetCompilationUnit)
        {
            var requredNamespaces = new List<string>()
            {
                "using SymOntoClay.Serialization;",
                "using System;"
            };

            if (targetCompilationUnit.Usings?.Any() ?? false)
            {
                requredNamespaces.AddRange(targetCompilationUnit.Usings);
            }

            var sourceCodeBuilder = new StringBuilder();
            sourceCodeBuilder.AppendLine("// <autogenerated />");
            foreach (var item in requredNamespaces.Distinct())
            {
                sourceCodeBuilder.AppendLine(item);
            }

            foreach (var targetCodeChunkItem in targetCompilationUnit.CodeChunkItems)
            {
                ProcessTargetCodeChunkItem(targetCodeChunkItem, sourceCodeBuilder);
            }

            var firstCodeChunkItem = targetCompilationUnit.CodeChunkItems.First();

            var fileName = $"{GetClassName(firstCodeChunkItem)}.g.cs";

            SaveFile(sourceCodeBuilder.ToString(), fileName);
        }

        private void ProcessTargetCodeChunkItem(CodeChunkItem targetCodeChunkItem, StringBuilder sourceCodeBuilder)
        {
            var identationStep = 4;
            var baseIdentation = 0;
            var classDeclIdentation = baseIdentation + identationStep;
            var classContentDeclIdentation = classDeclIdentation + identationStep;
            var classContentIdentation = classContentDeclIdentation + identationStep;

            sourceCodeBuilder.AppendLine();
            sourceCodeBuilder.AppendLine($"namespace {targetCodeChunkItem.Namespace}.ActionFactories");
            sourceCodeBuilder.AppendLine("{");
            sourceCodeBuilder.AppendLine($"{GeneratorsHelper.Spaces(classDeclIdentation)}[SocSerializableAction(Id = \"{targetCodeChunkItem.Identifier}\")]");
            sourceCodeBuilder.AppendLine($"{GeneratorsHelper.Spaces(classDeclIdentation)}public class {GetClassName(targetCodeChunkItem)} : ISocSerializableActionFactory");
            sourceCodeBuilder.AppendLine($"{GeneratorsHelper.Spaces(classDeclIdentation)}{{");
            sourceCodeBuilder.AppendLine($"{GeneratorsHelper.Spaces(classContentDeclIdentation)}public string Id => \"{targetCodeChunkItem.Identifier}\";");

            var actionFieldsDict = new Dictionary<int, string>();

            var useIndexInActionFieldName = targetCodeChunkItem.Lambdas.Count > 1;

            var n = 0;

            foreach (var lambda in targetCodeChunkItem.Lambdas)
            {
                var actionTypeName = GetActionTypeName(lambda);

                var actionName = GetActionFieldName(useIndexInActionFieldName, n);

                sourceCodeBuilder.AppendLine($"{GeneratorsHelper.Spaces(classContentDeclIdentation)}private {actionTypeName} {actionName} = {lambda.GetText()};");

                n++;

                actionFieldsDict[n] = actionTypeName;
            }

            if (useIndexInActionFieldName)
            {
                sourceCodeBuilder.AppendLine($"{GeneratorsHelper.Spaces(classContentDeclIdentation)}public object GetAction(int index)");
                sourceCodeBuilder.AppendLine($"{GeneratorsHelper.Spaces(classContentDeclIdentation)}{{");
                sourceCodeBuilder.AppendLine($"{GeneratorsHelper.Spaces(classContentIdentation)}switch(index)");
                sourceCodeBuilder.AppendLine($"{GeneratorsHelper.Spaces(classContentIdentation)}{{");
                foreach (var actionFieldItem in actionFieldsDict)
                {
                    sourceCodeBuilder.AppendLine($"{GeneratorsHelper.Spaces(classContentIdentation)}case {actionFieldItem.Key}: return {actionFieldItem.Value};");
                }
                sourceCodeBuilder.AppendLine($"{GeneratorsHelper.Spaces(classContentIdentation)}default: return null;");
                sourceCodeBuilder.AppendLine($"{GeneratorsHelper.Spaces(classContentIdentation)}}}");
                sourceCodeBuilder.AppendLine($"{GeneratorsHelper.Spaces(classContentDeclIdentation)}}}");
            }
            else
            {
                sourceCodeBuilder.AppendLine($"{GeneratorsHelper.Spaces(classContentDeclIdentation)}public object GetAction(int index) => _action;");
            }

            sourceCodeBuilder.AppendLine($"{GeneratorsHelper.Spaces(classDeclIdentation)}}}");
            sourceCodeBuilder.AppendLine("}");
        }

        private string GetClassName(CodeChunkItem targetCodeChunkItem)
        {
            return $"SocSerializableActionFactory{targetCodeChunkItem.Identifier.Replace("-", string.Empty)}";
        }

        private string GetActionFieldName(bool useIndexInActionFieldName, int n)
        {
            if (useIndexInActionFieldName)
            {
                return $"_action{n}";
            }

            return "_action";
        }

        private string GetActionTypeName(ParenthesizedLambdaExpressionSyntax lambda)
        {
            var parameterList = lambda.ParameterList;

            var parameterListChildNodes = parameterList.ChildNodes();

            if (parameterListChildNodes.Count() == 0)
            {
                return "Action";
            }

            var actionTypeName = string.Empty;
            var needToAddFuncResultType = false;
            var funcResultType = string.Empty;

            if (lambda.ChildNodes().Count() == 2)
            {
                actionTypeName = "Action";
            }
            else
            {
                needToAddFuncResultType = true;
                actionTypeName = "Func";

                var funcTypeNode = lambda.ChildNodes().ElementAt(0);

                funcResultType = GeneratorsHelper.ToString(funcTypeNode.GetText());
            }

            var genericTypeList = new List<string>();

            foreach (var parameter in parameterList.Parameters)
            {
                var identifierName = parameter.ChildNodes().FirstOrDefault(p => p.IsKind(SyntaxKind.IdentifierName));

                if (identifierName == null)
                {
                    var genericName = parameter.ChildNodes().FirstOrDefault(p => p.IsKind(SyntaxKind.GenericName));

                    if (genericName == null)
                    {
                        var predefinedType = parameter.ChildNodes().FirstOrDefault(p => p.IsKind(SyntaxKind.PredefinedType));

                        if (predefinedType == null)
                        {
                            genericTypeList.Add(string.Empty);
                        }
                        else
                        {
                            genericTypeList.Add(GeneratorsHelper.ToString(predefinedType.GetText()));
                        }
                    }
                    else
                    {
                        genericTypeList.Add(GeneratorsHelper.ToString(genericName.GetText()));
                    }
                }
                else
                {
                    genericTypeList.Add(GeneratorsHelper.ToString(identifierName.GetText()));
                }
            }

            if (needToAddFuncResultType)
            {
                genericTypeList.Add(funcResultType);
            }

            return $"{actionTypeName}<{string.Join(",", genericTypeList)}>";
        }

        private void SaveFile(string source, string fileName)
        {
            _context.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
        }
    }
}

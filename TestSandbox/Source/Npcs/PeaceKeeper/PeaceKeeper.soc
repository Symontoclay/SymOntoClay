/*app PeaceKeeper
{
	{: male(#Tom) :}
	{: parent(#Piter, #Tom) :}
	{: {son($x, $y)} -> { male($x) & parent($y, $x)} :}

	on Enter => {
	    select {: son($x, $y) :} >> @>log;
	}
}*/

{: { enemy($x) } -> { soldier($x) } :}

{: waypoint(#wp1) :}
{: soldier(#enemy1) :}
{: soldier(#enemy2) :}

app PeaceKeeper
{
    on Enter =>
	{
	    'Begin' >> @>log;

		select {: waypoint($x) :} >> @>log;

		'End' >> @>log;
	}
}

/*{: { enemy($x) } -> { soldier($x) } :}

app PeaceKeeper is soldier
{
    //idle actions
    //{
    //    go();
    //}
	
	on Enter =>
    {
        'Begin' >> @>log;

        go();

        'End' >> @>log;
    }
	
	fun go()
    {
	    'Begin go' >> @>log;
		`go and kill`(#@(waypoint & random));
		'End go' >> @>log;
    }
}

action `go and kill`
{
    op(@target)
	{
	    repeat
		{
		    'Begin go and kill' >> @>log;
		    `move and check`(@target)[: on complete { 'on complete go and kill (move and check)' >> @>log; complete action;} :];//, on weak canceled { 'on weak canceled go and kill (move and check)' >> @>log; weak cancel action; }
			//kill(#@{: see(I, $_) & enemy($_) & state($_, alive) :});
			'End go and kill' >> @>log;
		}
	}
}

action `move and check`
{
    op (@target)
	{
	    repeat
		{
		    'Begin move and check' >> @>log;
		    @@host.go(to: @target)[: timeout = 5, on complete { 'on complete move and check (move)' >> @>log; complete action;} :];//Don't make cascade "on weak canceled"!
		    //move(@target)[: timeout = 5, on complete { 'on complete move and check (move)' >> @>log; complete action;} :];//Don't make cascade "on weak canceled"!
			check();
			'End move and check' >> @>log;
		}
	}
	
    //on {: see(I, $_) & enemy($_) & state($_, alive) :} => 
	//{
	//    'see(I, $_) & enemy($_) & state($_, alive)' >> @>log;
	//	weak cancel action;
	//}
}

action check
{
    op ()
	{
	    'Begin check' >> @>log;
	
	    @@host.`stop`();
	    @@host.`rotate`(30);
		@@host.`rotate`(-60);
		@@host.`rotate`(30);
		
		'End check' >> @>log;
	}
}

action move
{		
	op (@target)
	{
		@@host.go(to: @target);
	}
}

action kill
{
    on leave 
	{
	   `stop shoot`(); 
	}

    op (@target)
	{
	    'Begin kill' >> @>log;
		'kill: ' + @target >> @>log;
		@_target = @target;
		'kill: ' + @_target >> @>log;
		`ready for shoot`();
		aim();
		shoot();
		await;
		'End kill' >> @>log;
	}

	on {: state(@_target, dead) :}
	{
	    'state(@_target, dead)' >> @>log;

	    complete action;
	}

	on {: !see(I, @_target) :}
	{
	    '!see(I, @_target)' >> @>log;
		select {: !see(I, @_target) :} >> @>log;
	    weak cancel action;
	}

	on each 5
	{
	    'Begin on each 5' >> @>log;
	    aim();
		'End on each 5' >> @>log;
	}

	fun aim()
	{
	    'Begin aim' >> @>log;
		@_target >> @>log;
	    @@host.`aim to`(@_target);
		'End aim' >> @>log;
	}

	fun shoot()
	{
	    'Begin shoot' >> @>log;
	    @@host.`start shoot`();
		'End shoot' >> @>log;
	}

	fun `stop shoot`()
	{
	    'Begin stop shoot' >> @>log;
	    @@host.`stop shoot`();
		'End stop shoot' >> @>log;
	}

	fun `ready for shoot`()
	{
	    'Begin ready for shoot' >> @>log;
	    @@host.`ready for shoot`();
		'End ready for shoot' >> @>log;
	}

	private:
	    var @_target;
}*/
